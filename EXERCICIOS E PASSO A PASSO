# criar projeto React (com Vite)
npm create vite@latest nome-do-projeto
# escolhe â†’ React + JavaScript
cd nome-do-projeto

# instalar dependÃªncias
npm install

# abrir VS Code
code .

# rodar o servidor
npm run dev




ğŸ¥‡ 1. ENTENDA O ENUNCIADO

ğŸ‘‰ Antes de codar, lÃª com calma e procura as palavras mÃ¡gicas.
Essas palavras indicam o que vai virar estado (useState).

ğŸ’¡ Palavras que sempre indicam estado:

tentativas
selecionado / virada / aberta / achada
pontuaÃ§Ã£o
erro / mensagem
senha / combinaÃ§Ã£o
cartas / teclas / letras / nÃºmeros

ğŸ§© Tudo que muda na tela = precisa estar num useState.
ğŸ‘‰ se aparece e depois some, muda de cor, muda nÃºmero, texto â†’ useState.


ğŸ¥ˆ 2. MONTE O ESQUELETO DO COMPONENTE PRINCIPAL
import { useState } from "react";

export default function NomeDoJogo() {
  // ESTADOS (tudo que muda)
  const [tentativas, setTentativas] = useState(3);
  const [mensagem, setMensagem] = useState("");
  const [fim, setFim] = useState(false);
  
  // DADOS INICIAIS (array)
  const cartas = [
    { id: 1, nome: "MaÃ§Ã£" },
    { id: 2, nome: "Banana" },
  ];

  return (
    <div>
      <h1>TÃ­tulo do jogo</h1>
      <p>Tentativas: {tentativas}</p>
    </div>
  );
}


ğŸ¥‰ 3. SE TEM LISTA DE COISAS (CARTAS, BOTÃ•ES, TECLAS)

Cria um array (ex: cartas, teclas, botoes) e renderiza ele com .map().

Modelinho universal do map:
{lista.map((item, index) => (
  <button key={index} onClick={() => funcao(index)}>
    {item.nome}
  </button>
))}


ğŸ§± 4. SEMPRE PRECISA DE UMA FUNÃ‡ÃƒO PARA O CLIQUE (onClick)

Tudo no React interativo Ã© clique.

Modelinho:
function clicar(index) {
  console.log("Clicou na posiÃ§Ã£o", index);
}
DEPOIS LIGA ELA
<button onClick={() => clicar(index)}>Clique</button>


ğŸ§© 5. MONTA A LÃ“GICA DO JOGO / REGRAS

Depende do enunciado, mas quase sempre Ã© isso:

Tipo de jogo	O que fazer no clique	O que comparar / alterar
Cofre	mudar nÃºmero da posiÃ§Ã£o	comparar com senha
Jogo 21	virar carta	somar valor e checar 21
MemÃ³ria	selecionar carta	comparar id das cartas
Forca	clicar letra	checar se letra existe na palavra
Calculadora	clicar nÃºmero/op	montar expressÃ£o e usar eval

ğŸ’¡ Dica: sempre que precisar â€œcomparar dois cliquesâ€, usa dois estados:
const [selA, setSelA] = useState(null);
const [selB, setSelB] = useState(null);

Depois:
if (selA !== null && selB !== null) {
  validar(selA, selB);
}


ğŸ’¡ 6. MONTE A FUNÃ‡ÃƒO DE VALIDAÃ‡ÃƒO / RESULTADO

Essa funÃ§Ã£o checa se o jogador acertou, errou, ganhou ou perdeu.


function validar() {
  if (pontuacao === 21) {
    setMensagem("ParabÃ©ns, vocÃª ganhou!");
    setFim(true);
  } else if (pontuacao > 21) {
    setMensagem("VocÃª perdeu!");
    setFim(true);
  }
}

OUTRO CASO

function validar(idA, idB) {
  if (cartasA[idA].id === cartasB[idB].id) {
    setMensagem("Acertou!");
  } else {
    setMensagem("Errou!");
    setTentativas(t => t - 1);
  }
}


ğŸ” 9. SE TIVER â€œTENTAR NOVAMENTEâ€ OU â€œREINICIARâ€

Faz uma funÃ§Ã£o pra resetar tudo:

function reiniciar() {
  setTentativas(5);
  setMensagem("");
  setFim(false);
}

E cria um botÃ£o pra isso:

<button onClick={reiniciar}>Tentar Novamente</button>



ğŸš€ FRASES-CHAVE PRA LEMBRAR NA PROVA

â€œTudo que muda na tela â†’ useState.â€
â€œTudo que aparece vÃ¡rias vezes â†’ array + map.â€
â€œTudo que reage ao clique â†’ onClick.â€
â€œTudo que precisa comparar â†’ funÃ§Ã£o validar().â€
â€œTudo que tem fim de jogo â†’ flag fim = true.â€

ğŸ’¬ Resumo final:

1ï¸âƒ£ Identifica o que vai mudar (cria os useState)
2ï¸âƒ£ Cria o layout bÃ¡sico (return)
3ï¸âƒ£ Mostra listas com .map()
4ï¸âƒ£ Cria as funÃ§Ãµes de clique
5ï¸âƒ£ Faz a regra de validaÃ§Ã£o
6ï¸âƒ£ Mostra as mensagens
7ï¸âƒ£ Testa no navegador

99999999999999999999999999999999999999999999999999999999999999999999999999999

********* COFRE PROVA ANTIGA **********
TECLA.JSX

// Componente TECLA
// O enunciado pede um componente que mostre um nÃºmero (0..9) com dois botÃµes
// para decremento (-) e incremento (+), "dando a volta" (0 vai para 9 e 9 vai para 0).
// Ele deve receber o valor atual e uma funÃ§Ã£o onChange(newVal) do pai.

export default function Tecla({ value, onChange }) {
  // decrementa com wrap 0â†’9
  function dec() {
    const novo = value === 0 ? 9 : value - 1;
    onChange(novo); // informa o pai que mudou
  }

  // incrementa com wrap 9â†’0
  function inc() {
    const novo = value === 9 ? 0 : value + 1;
    onChange(novo); // informa o pai que mudou
  }

  return (
    <div style={wrapper}>
      <button onClick={dec} style={btn}>-</button>
      <span style={visor}>{value}</span>
      <button onClick={inc} style={btn}>+</button>
    </div>
  );
}

const wrapper = { display: "inline-flex", alignItems: "center", gap: 8, margin: 6 };
const btn = { padding: "6px 10px", cursor: "pointer" };
const visor = { minWidth: 16, textAlign: "center", fontWeight: "bold" };

---------------------------------------------------------------------------------------

// Componente COFRE
// Enunciado-chave (o que ele quer checar):
// - Receber uma senha por prop (string), ex: "1234"
// - Criar uma Tecla para cada dÃ­gito da senha
// - Estado com a combinaÃ§Ã£o atual (comeÃ§a tudo 0,0,0,0...)
// - BotÃ£o "Abrir": se combinaÃ§Ã£o === senha â†’ "Cofre Aberto!", senÃ£o "Senha Errada!"
// - Limitar tentativas a 3 e desabilitar o botÃ£o quando acabar

import { useMemo, useState } from "react";
import Tecla from "./Tecla";

export default function Cofre({ senha }) {
  // Transforma "1234" â†’ [1,2,3,4]
  const senhaNumerica = useMemo(
    () => senha.split("").map(n => Number(n)),
    [senha]
  );

  // combinaÃ§Ã£o atual digitada pelo usuÃ¡rio (comeÃ§a tudo 0)
  const [comb, setComb] = useState(() => Array(senhaNumerica.length).fill(0));
  const [tentativas, setTentativas] = useState(3);
  const [msg, setMsg] = useState("");
  const [aberto, setAberto] = useState(false); // se abriu, fim de jogo

  function alterarPosicao(indice, novoValor) {
    // atualiza comb na posiÃ§Ã£o "indice" com "novoValor"
    setComb(prev => {
      const copia = [...prev];
      copia[indice] = novoValor;
      return copia;
    });
  }

  function abrir() {
    if (aberto || tentativas <= 0) return;

    // compara comb com senhaNumerica
    const ok = comb.every((v, i) => v === senhaNumerica[i]);
    if (ok) {
      setAberto(true);
      setMsg("Cofre Aberto!");
    } else {
      const rest = tentativas - 1;
      setTentativas(rest);
      setMsg("Senha Errada!");
    }
  }

  const esgotou = !aberto && tentativas === 0;

  return (
    <div style={box}>
      <h2>Cofre</h2>

      <div style={{ marginBottom: 8 }}>
        {comb.map((valor, i) => (
          <Tecla
            key={i}
            value={valor}
            onChange={(novo) => alterarPosicao(i, novo)}
          />
        ))}
      </div>

      <button
        onClick={abrir}
        disabled={aberto || tentativas === 0}
        style={{ padding: "8px 16px", cursor: (aberto || tentativas === 0) ? "not-allowed" : "pointer" }}
      >
        Abrir
      </button>

      <div style={{ marginTop: 8, minHeight: 20 }}>
        {aberto && <strong style={{ color: "green" }}>{msg}</strong>}
        {!aberto && tentativas < 3 && <span>{msg}</span>}
      </div>

      {!aberto && (
        <p style={{ marginTop: 6 }}>Tentativas restantes: {tentativas}</p>
      )}

      {esgotou && <p style={{ color: "crimson" }}>VocÃª usou todas as tentativas.</p>}
    </div>
  );
}

const box = { border: "1px solid #ddd", padding: 12, borderRadius: 8, maxWidth: 420 };

############################################################################################

************** Jogo 21 (Prova antiga) **********************
SuposiÃ§Ãµes coerentes com o enunciado

Recebe tentativas, verso e listaCartas (cada carta tem {id, valor, img}).
Cada clique vira uma carta e consome 1 tentativa.
Se a soma == 21 â†’ venceu, > 21 â†’ perdeu, acabaram tentativas â†’ â€œTerminou com X pontosâ€.
Depois do fim do jogo, nÃ£o pode virar mais cartas.

CARTA.JSX
// Exibe uma "carta": se virada, mostra a frente (img); senÃ£o, mostra o verso.
// Desabilita clique se jÃ¡ virada ou se jogo acabou.
export default function Carta({ virada, imgFrente, imgVerso, onVirar, desabilitada }) {
  return (
    <button
      onClick={onVirar}
      disabled={desabilitada || virada}
      style={{
        border: "1px solid #ccc",
        borderRadius: 8,
        padding: 0,
        width: 100,
        height: 140,
        cursor: (desabilitada || virada) ? "not-allowed" : "pointer",
        overflow: "hidden",
      }}
    >
      <img
        alt="carta"
        src={virada ? imgFrente : imgVerso}
        style={{ width: "100%", height: "100%", objectFit: "cover" }}
      />
    </button>
  );
}
------------------------------------------------------------------------

// Componente principal do jogo 21
// Props pedidas: tentativas (nÂº de viradas permitidas), verso (img do verso), listaCartas (array de cartas {id, valor, img})

import { useMemo, useState } from "react";
import Carta from "./Carta";

export default function JogoVinteUm({ tentativas, verso, listaCartas }) {
  // embaralha as cartas para a partida
  const baralho = useMemo(
    () => [...listaCartas].sort(() => Math.random() - 0.5),
    [listaCartas]
  );

  // viradas[i] = true/false
  const [viradas, setViradas] = useState(() => Array(baralho.length).fill(false));
  const [restantes, setRestantes] = useState(tentativas);
  const [pontuacao, setPontuacao] = useState(0);
  const [fim, setFim] = useState(null); // "win" | "lose" | "fimTentativas" | null

  const jogoEncerrado = fim !== null;

  function virarCarta(i) {
    if (jogoEncerrado) return;
    if (viradas[i]) return;           // nÃ£o vira de novo a mesma
    if (restantes <= 0) return;       // sem tentativas

    const carta = baralho[i];
    // consome tentativa
    setRestantes((r) => r - 1);
    // vira visualmente
    setViradas((v) => {
      const copia = [...v];
      copia[i] = true;
      return copia;
    });

    // atualiza pontuaÃ§Ã£o
    setPontuacao((p) => {
      const novo = p + carta.valor;

      // checa condiÃ§Ãµes de tÃ©rmino
      if (novo === 21) {
        setFim("win");
      } else if (novo > 21) {
        setFim("lose");
      } else {
        // se nÃ£o acabou por pontuaÃ§Ã£o, pode acabar por falta de tentativa
        // (nota: usamos callback do setState para garantir ordem)
        setRestantes((r) => {
          if (r - 1 === 0 && novo < 21) {
            setFim("fimTentativas");
          }
          return r; // nÃ£o mexe aqui, pois jÃ¡ consumimos antes
        });
      }

      return novo;
    });
  }

  function mensagem() {
    if (fim === "win") return "ParabÃ©ns vocÃª ganhou!";
    if (fim === "lose") return "VocÃª perdeu!";
    if (fim === "fimTentativas") return `VocÃª terminou com ${pontuacao} pontos!`;
    return null;
  }

  return (
    <div>
      <h2>Jogo 21</h2>
      <p>Tentativas restantes: {restantes}</p>
      <p>PontuaÃ§Ã£o: {pontuacao}</p>

      <div style={grid}>
        {baralho.map((c, i) => (
          <Carta
            key={c.id}
            virada={viradas[i]}
            imgFrente={c.img}
            imgVerso={verso}
            desabilitada={jogoEncerrado}
            onVirar={() => virarCarta(i)}
          />
        ))}
      </div>

      <div style={{ minHeight: 24, marginTop: 8 }}>
        {mensagem() && <strong>{mensagem()}</strong>}
      </div>
    </div>
  );
}

const grid = {
  display: "grid",
  gridTemplateColumns: "repeat(auto-fill, minmax(100px, 1fr))",
  gap: 12,
};

-------------------------------------------------------------------------

// Exemplo de integraÃ§Ã£o exatamente como o enunciado sugere
// (assume que vocÃª tem um Deck.js que exporta { verso, listaCartas })

import { verso, listaCartas } from "./Deck";
import JogoVinteUm from "./JogoVinteUm";

export default function App() {
  return (
    <div style={{ padding: 16 }}>
      <h1>Prova â€” Jogo 21</h1>
      <JogoVinteUm tentativas={4} verso={verso} listaCartas={listaCartas} />
    </div>
  );
}

######################################################################
CALCULADORA 

import { useState } from "react";

export default function Calculadora() {
  // estado que guarda a expressÃ£o digitada (ex.: "12+3*4")
  const [expr, setExpr] = useState("");

  const botoes = [
    "7","8","9","/",
    "4","5","6","*",
    "1","2","3","-",
    "C","0","=","+",
  ];

  function clickBtn(btn) {
    if (btn === "C") {
      setExpr("");
      return;
    }
    if (btn === "=") {
      try {
        const resultado = eval(expr);           // do enunciado
        setExpr(String(resultado));
      } catch {
        setExpr(""); // se der erro de sintaxe, sÃ³ limpa (simples)
      }
      return;
    }
    // caso comum: concatena nÃºmero ou operador
    setExpr((prev) => prev + btn);
  }

  return (
    <div style={{ width: 260, margin: "20px auto" }}>
      <h2>Calculadora</h2>
      <input value={expr} readOnly style={{ width: "100%", height: 40, textAlign: "right", fontSize: 20, marginBottom: 8 }} />
      <div style={{ display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 8 }}>
        {botoes.map((b) => (
          <button key={b} onClick={() => clickBtn(b)} style={{ height: 44, fontSize: 18 }}>
            {b}
          </button>
        ))}
      </div>
    </div>
  );
}


###########################################################################
JOGO DA FORCA

// Mostra a palavra como botÃµes/letras: se ainda nÃ£o descoberta, mostra "-"

export default function Forca({ palavra, letrasCertas }) {
  return (
    <div style={{ display: "flex", gap: 6, flexWrap: "wrap" }}>
      {palavra.split("").map((letra, i) => {
        const visivel = letrasCertas.has(letra);
        return (
          <button key={i} disabled style={{ padding: "6px 10px" }}>
            {visivel ? letra : "-"}
          </button>
        );
      })}
    </div>
  );
}


TECLADO.JSX
const ALFABETO = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");

export default function Teclado({ onPress, usados }) {
  return (
    <div style={{ display: "flex", gap: 6, flexWrap: "wrap", marginTop: 10 }}>
      {ALFABETO.map((l) => (
        <button
          key={l}
          onClick={() => onPress(l)}
          disabled={usados.has(l)}
          style={{ padding: "6px 10px", cursor: usados.has(l) ? "not-allowed" : "pointer" }}
        >
          {l}
        </button>
      ))}
    </div>
  );
}


JOGODAFORCA.JSX
import { useState } from "react";
import Forca from "./Forca";
import Teclado from "./Teclado";

// Regras do enunciado (adaptadas):
// - Recebe a palavra por prop
// - Contabiliza erros; com >3 erros â†’ "VocÃª perdeu!"
// - Se descobrir todas as letras â†’ "ParabÃ©ns! VocÃª ganhou!"
// - Exibe tentativas erradas

export default function JogoDaForca({ palavra }) {
  const [certas, setCertas] = useState(new Set());
  const [usadas, setUsadas] = useState(new Set());
  const [erros, setErros] = useState(0);
  const [fim, setFim] = useState(null); // "win" | "lose" | null

  function apertar(letra) {
    if (fim) return;
    if (usadas.has(letra)) return;

    setUsadas((u) => new Set(u).add(letra));

    if (palavra.includes(letra)) {
      const novo = new Set(certas).add(letra);
      setCertas(novo);
      const venceu = palavra.split("").every(ch => novo.has(ch));
      if (venceu) setFim("win");
    } else {
      setErros((e) => {
        const prox = e + 1;
        if (prox > 3) setFim("lose");
        return prox;
      });
    }
  }

  return (
    <div>
      <h2>Jogo da Forca</h2>
      <Forca palavra={palavra} letrasCertas={certas} />
      <p>Erros: {erros}</p>

      {!fim && <Teclado onPress={apertar} usados={usadas} />}

      <div style={{ marginTop: 8 }}>
        {fim === "win" && <strong style={{ color: "green" }}>ParabÃ©ns! VocÃª ganhou!</strong>}
        {fim === "lose" && <strong style={{ color: "crimson" }}>VocÃª perdeu!</strong>}
      </div>
    </div>
  );
}

APP.JSX
import JogoDaForca from "./JogoDaForca";

export default function App() {
  return (
    <div style={{ padding: 16 }}>
      <JogoDaForca palavra="REACT" />
    </div>
  );
}



